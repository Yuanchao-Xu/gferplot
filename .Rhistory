#'     thigmophobe.labels(data$x, data$y, data$Province, offset = 1)
#'   }
#'
#'
#'   if (line == TRUE) {
#'     # add ablines of national mean or mean
#'     if (is.null(xmean)) xmean <- round(mean(data$x), 2)
#'     if (is.null(ymean)) ymean <- round(mean(data$y), 2)
#'     abline(h = ymean, v = xmean, col = '#c00000', lwd = 3, lty = 2)
#'   }
#'
#'   #spread.labels(data$x, data$y, data$Province, offsets = 0.01)
#'
#' }
#'
#'
#'
#' #' plotWaternomics_legend
#' #'
#' #' legend for plot special waternomics chart for CWR
#' #'
#' #' @param label whether to show label, default is TRUE
#' #' @importFrom mapplots add.pie
#' #' @importFrom graphics plot abline text
#' #' @importFrom grDevices rgb
#' #' @export
#' #' @examples
#' #' \dontrun{
#' #' plotwaternomics_legend()
#' #' }
#' plotWaternomics_legend <- function(label = TRUE) {
#'   r <- c(5, 3, 1.5)
#'   x <- c(0, 0, 0)
#'   y <- c(7, 16, 21)
#'   plot (x, y, xlim = c(-3, 3), ylim = c(0, 23), xaxt = 'n', yaxt = 'n', bty = 'n')
#'
#'   col <- c(rgb(107/255, 128/255, 51/255), rgb(2/255, 3/255, 3/255), rgb(13/255, 119/255, 185/255))
#'
#'   for (i in 1:3) {
#'     add.pie(x = x[i], y = y[i], z = c(1, 1, 1), radius = r[i], labels = '', col = col, border = 'white')
#'   }
#'   if (label == TRUE) {
#'     size <- 1.2
#'     text(-0.7, 8.5, "Service", col = 'white', cex = size)
#'     text(0.7, 8.5, "Agriculture", col = 'white', cex = size)
#'     text(0, 4, "Industry", col = 'white', cex = size)
#'   }
#' }
#'
#'
#'
#'
#'
#' getLim <- function(x) {
#'   # decide axis interval
#'   dig <- nchar(min(round(x)))
#'
#'   x1 <- round(min(x) - (max(x) - min(x))/length(x), -(dig - 1))
#'   x2 <- round(max(x) + (max(x) - min(x))/length(x), -(dig - 1))
#'
#'   return(c(x1, x2))
#' }
#'
#'
#'
plotScatterPie(data)
plotScatterPie <- function(data, xmeanLine = TRUE, ymeanLine = TRUE, labelLine = NULL) {
with (data, {
layer_basic <- ggplot()
#  layer_points <- geom_point(data = data, aes(x, y, size = radius))
data$radius <- getRadius(data$GDP)
col <- c(rgb(107/255, 128/255, 51/255), rgb(2/255, 3/255, 3/255), rgb(13/255, 119/255, 185/255))
layer_pie <- geom_scatterpie(data = data, aes(x, y, r = radius),
cols = colnames(data)[3:5], color = NA)
if (is.null(labelLine)) labelLine <- max(data$radius)/3
layer_label <- geom_text_repel(data = data, aes(x, y, label = Province),
point.padding = unit(labelLine, "lines"))
#layer_legend <- geom_scatterpie_legend(data$radius, x= 0, y=0)
layer_plot <- layer_basic + layer_pie + layer_label + scale_fill_manual(values=col) + coord_equal()
if (xmeanLine == TRUE) layer_plot <- layer_plot + geom_vline(xintercept = mean(data$x), color = 'red', size = 1.5, linetype = 2)
if (ymeanLine == TRUE) layer_plot <- layer_plot + geom_hline(yintercept = mean(data$y), color = 'red', size = 1.5, linetype = 2)
style <- ggstyle()
print(layer_plot + style)
})
}
devtools::check(cran=T)
plotScatterPie(GDPmix)
devtools::document()
devtools::check(cran=T)
rm(list=ls())
load("~/GitHub/gferplot/.RData")
rm(list=ls())
devtools::check(cran=T)
plotScatterPie(GDPmix)
GDP_CWR <- c(rgb(107/255, 128/255, 51/255), rgb(2/255, 3/255, 3/255), rgb(13/255, 119/255, 185/255))
GDP_CWR
devtools::use_data(GDP_CWR,GDP_CWR)
str(GDP_CWR)
rm(list=ls())
GDPmix
data(GDPmix)
devtools::check(cran=T)
devtools::use_data(GDPmix,GDPmix)
devtools::document
devtools::document()
devtools::check(cran=T)
devtools::check(cran=T)
GDPColor_CWR <- c("#6B8033", "#020303", "#0D77B9")
colnames(GDPmix) <- c('label', 'r', '1st', '2nd', '3rd', 'x', 'y')
plotScatterPie(GDPmix, pieRange = 3:5, pieColor = GDPColor_CWR)
devtools::check(cran=T)
plotScatterPie(GDPmix, pieRange = 3:5, pieColor = GDPColor_CWR)
install.packages('circlize')
name=c(3,10,10,3,6,7,8,3,6,1,2,2,6,10,2,3,3,10,4,5,9,10)
feature=paste("feature ", c(1,1,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5) , sep="")
dat <- data.frame(name,feature)
dat <- with(dat, table(name, feature))
# Charge the circlize library
library(circlize)
chordDiagram(as.data.frame(dat), transparency = 0.5)
data
dat
as.data.frame(dat)
str(dat)
dat
feature
as.data.frame(dat)
rep(c(rep(1, 4), 8), 3)
devtools::check(cran=T)
devtools::check(cran=T)
devtools::check(cran=T)
devtools::check(cran=T)
chordDiagram
name=c(3,10,10,3,6,7,8,3,6,1,2,2,6,10,2,3,3,10,4,5,9,10)
feature=paste("feature ", c(1,1,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5) , sep="")
dat <- data.frame(name,feature)
dat <- with(dat, table(name, feature))
chordDiagram(as.data.frame(dat), transparency = 0.5)
chordDiagram(as.data.frame(dat), transparency = 0)
chordDiagram(as.data.frame(dat), transparency = 0)
devtools::check(cran=T)
name=c(3,10,10,3,6,7,8,3,6,1,2,2,6,10,2,3,3,10,4,5,9,10)
feature=paste("feature ", c(1,1,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5) , sep="")
dat <- data.frame(name,feature)
dat <- with(dat, table(name, feature))
# Charge the circlize library
library(circlize)
# Make the circular plot
chordDiagram(as.data.frame(dat), transparency = 0.5)
name=c(3,10,10,3,6,7,8,3,6,1,2,2,6,10,2,3,3,10,4,5,9,10)
feature=paste("feature ", c(1,1,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5) , sep="")
dat <- data.frame(name,feature)
dat <- with(dat, table(name, feature))
# Charge the circlize library
library(circlize)
# Make the circular plot
chordDiagram(as.data.frame(dat), transparency = 0.5)
as.data.frame(dat)
dat
a <- read.table('clipboard', header = T)
a <- read.table('clipboard', header = T)
a
a <- read.table('clipboard', header = T, sep = ' ')
a <- read.table('clipboard', header = T, sep = '    ')
a <- read.table('clipboard', header = T, sep = '    ')
a <- read.table('clipboard', header = T)
a <- read.table('clipboard', header = T)
a <- read.table('clipboard', header = T, sep = '  ')
Name  	Policy and planning  	Investment  	Water security  	Flood and draught  	Research  	Water infrastructure  	Water supply  	Ecological protection  	Supervison and coordination  	Pollution control  	Nuclear safety  	Environmental disclosure  	Water Price/tax
NDRC	1	1	1	1	0	1	1	1	1	1	1	1	1
MIIT	1	1	1	0	0	0	0	1	1	1	0	0	1
MoF	1	1	0	0	0	0	0	0	1	0	0	1	2
MLR	1	0	1	0	1	0	0	1	1	0	0	1	1
MEP	1	1	0	0	1	0	1	1	2	2	1	2	1
MoHURD	1	0	0	1	0	1	1	1	1	1	0	1	1
MWR	1	1	3	1	2	2	1	1	1	0	0	0	1
MoA	1	0	0	0	1	1	1	1	0	1	0	0	1
NHFP	1	0	1	0	0	0	1	1	0	1	0	0	0
SAT	1	0	0	0	0	0	0	0	0	0	0	0	2
SFA	1	0	0	0	0	0	0	1	0	1	0	0	0
data.frame(name,feature)
with(dat, table(name, feature))
table(name, feature)
feature
a <- read.table('clipboard', header = T)
a
a <- read.table('clipboard', header = '  ')
a <- read.table('clipboard', header = '  ')
a <- read.table('clipboard', header = T. sep = '  ')
a <- read.table('clipboard', header = T, sep = '  ')
a <- read.table('clipboard', header = T, sep = ' ')
a
a <- read.table('clipboard', header = T, sep = ',')
a
a <- read.table('clipboard', header = T, sep = '')
a
a <- read.table('clipboard', header = T, sep = ' ')
a
a <- read.table('clipboard', header = T, sep = '  ')
a <- read.table('clipboard', header = T, sep = ',')
a
gusb('.', ' ', a)
gsub('.', ' ', a)
a
gsub('.', ' ', a[1])
a[1]
a[2]
gsub('.', ' ', a[2])
a[[2]]
a
str(a)
a[, 1]
rownames(a)
conames(a)
colnames(a)
gsub('.', ' ', colnames(a))
gsub('.', ' ', colnames(a)[2])
Name,	Policy and planning,	Investment,	Water security,	Flood and draugh,	Research,	Water infrastructure,	Water supply,	Ecological protection,	Supervison and coordination,	Pollution control,	Environmental disclosure,	Water Price/tax,
Name,	Policy and planning,	Investment,	Water security,	Flood and draugh,	Research,	Water infrastructure,	Water supply,	Ecological protection,	Supervison and coordination,	Pollution control,	Environmental disclosure,	Water Price/tax,
colnames(a)[2]
gsub('.', ' ', colnames(a)[2])
gsub('[.]', ' ', colnames(a)[2])
gsub('[.]', ' ', colnames(a))
b <- gsub('[.]', ' ', colnames(a))[1:13]
b
c <- read.table('clipboard', header = F)
c <- read.table('clipboard', header = F)
c
colnames(c)
colnames(c) <- b
c
library(tidyr)
gather(c, value, 2:13)
gather(c, value, 2:12)
c
str(c)
c[,2]
c[,13]
c[,1]
gather(c, value)
c
gather(c, value, 2:13)
gather(c, value, -name)
gather(c, responsibility, value, 2:13)
d <- gather(c, responsibility, value, 2:13)
gather(c, 'responsibility', 'value', 2:13)
d
chordDiagram(d)
d
c
CM <- c
devtools::use_data(CM, CM)
data <- cm
a <- gather(data, 'responsibility', 'value', 2:ncol(data))
chordDiagram(a, annotationTrack = "grid")
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
small_gap = 1
big_gap = 20
nr = nrow(a)
nc = ncol(a)
row_sum = sum(rowSums(abs(a)))
col_sum = sum(colSums(abs(a)))
a <- gather(data, 'responsibility', 'value', 2:ncol(data))
library(tidyr)
a <- gather(data, 'responsibility', 'value', 2:ncol(data))
data <- cm
data
data("cm")
load("~/GitHub/gferplot/data/cm.rda")
a <- gather(data, 'responsibility', 'value', 2:ncol(data))
data <- cm
a <- gather(data, 'responsibility', 'value', 2:ncol(data))
chordDiagram(a, annotationTrack = "grid")
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
small_gap = 1
big_gap = 20
nr = nrow(a)
nc = ncol(a)
row_sum = sum(rowSums(abs(a)))
col_sum = sum(colSums(abs(a)))
rowSums
?rowSums
x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
x
mat
library(circlize)
mat
row_sum = sum(rowSums(abs(data)))
col_sum = sum(colSums(abs(data)))
data
x
rowsums(x)
rowSums(x)
colSums(x)
sum(rowSums(x))
data
a
chordDiagram(a, annotationTrack = "grid")
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
small_gap = 1
big_gap = 20
nr = nrow(a)
nc = ncol(a)
row_sum = sum(a[,3])
col_sum = sum(a[,3])
n_sector = nr + nc
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * (row_sum/(row_sum + col_sum)) +
small_gap*(nr-1)
abline(h = 0, lty = 2, col = "#00000080")
start_degree = 90 - (180 - row_sector_degree)/2
gaps = c(rep(small_gap, nrow(mat) - 1), big_gap, rep(small_gap, ncol(mat) - 1), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
gaps = c(rep(small_gap, nrow(mat) - 1), big_gap, rep(small_gap, ncol(mat) - 1), big_gap)
gaps = c(rep(small_gap, nrow(data) - 1), big_gap, rep(small_gap, ncol(data) - 1), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
abline(h = 0, lty = 2, col = "#00000080")
gaps = c(rep(small_gap, nrow(mat) - 1), big_gap, rep(small_gap, ncol(mat) - 1), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
gaps
gaps = c(rep(small_gap, nrow(data) - 1), big_gap, rep(small_gap, ncol(data) - 1), big_gap)
gaps
nr = nrow(data)
nc = ncol(data)
nr
nc
n_sector = nr + nc
n_sector
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * (row_sum/(row_sum + col_sum)) +
small_gap*(nr-1)
row_sector_degree
gaps = c(rep(small_gap, nrow(data) - 1), big_gap, rep(small_gap, ncol(data) - 1), big_gap)
gaps
chordDiagram(a, annotationTrack = "grid")
a <- gather(data, 'responsibility', 'value', 2:ncol(data))
chordDiagram(a, annotationTrack = "grid")
circos.clear()
chordDiagram(a, annotationTrack = "grid")
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
small_gap = 1
big_gap = 20
nr = nrow(data)
nc = ncol(data)
row_sum = sum(a[,3])
col_sum = sum(a[,3])
n_sector = nr + nc
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * (row_sum/(row_sum + col_sum)) +
small_gap*(nr-1)
gaps = c(rep(small_gap, nrow(data) - 1), big_gap, rep(small_gap, ncol(data) - 1), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
chordDiagram(mat, grid.col = grid.col)
abline(v = 0, lty = 2, col = "#00000080")
abline(v = 0, lty = 2, col = "#00000080")
start_degree = 90 - (180 - row_sector_degree)/2
gaps = c(rep(small_gap, nrow(data) - 1), big_gap, rep(small_gap, ncol(data) - 1), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
circos.clear()
chordDiagram(a, annotationTrack = "grid")
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
small_gap = 1
big_gap = 20
nr = nrow(data)
nc = ncol(data)
row_sum = sum(a[,3])
col_sum = sum(a[,3])
n_sector = nr + nc
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * (row_sum/(row_sum + col_sum)) +
small_gap*(nr-1)
start_degree = 90 - (180 - row_sector_degree)/2
gaps = c(rep(small_gap, nrow(data) - 1), big_gap, rep(small_gap, ncol(data) - 1), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
gaps = c(rep(small_gap, nrow(data) - 1), big_gap, rep(small_gap, ncol(data) - 1), big_gap)
chordDiagram(a, annotationTrack = "grid")
circos.clear()
chordDiagram(a, annotationTrack = "grid")
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
small_gap = 1
circos.par(gap.after = gaps, start.degree = start_degree)
circos.clear()
chordDiagram(a, annotationTrack = "grid")
circos.par(gap.after = gaps, start.degree = start_degree)
circos.clear()
circos.par(gap.after = gaps, start.degree = start_degree)
abline(v = 0, lty = 2, col = "#00000080")
abline(h = 0, lty = 2, col = "#00000080")
circos.clear()
circos.par(gap.after = gaps, start.degree = start_degree)
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
circos.clear()
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
chordDiagram(a, annotationTrack = "grid")
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
gaps = c(rep(small_gap, nrow(data) - 1), big_gap, rep(small_gap, ncol(data) - 1), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
circos.clear()
circos.par(gap.after = gaps, start.degree = start_degree)
chordDiagram(a, annotationTrack = "grid")
circos.clear()
circos.par(gap.after = gaps, start.degree = start_degree)
chordDiagram(a, annotationTrack = "grid")
set.seed(123)
mat2 = matrix(rnorm(100), 10)
set.seed(999)
mat = matrix(sample(18, 18), 3, 6)
rownames(mat) = paste0("S", 1:3)
colnames(mat) = paste0("E", 1:6)
mat
circos.par(gap.after = c(rep(5, nrow(mat)-1), 15, rep(5, ncol(mat)-1), 15))
chordDiagram(mat)
gap.after = c(rep(5, nrow(mat)-1), 15, rep(5, ncol(mat)-1), 15)
gap.after
row_sum = sum(rowSums(abs(mat)))
col_sum = sum(colSums(abs(mat)))
small_gap = 1
big_gap = 20
nr = nrow(mat)
nc = ncol(mat)
n_sector = nr + nc
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * (row_sum/(row_sum + col_sum)) +
small_gap*(nr-1)
nr = nrow(mat)
nc = ncol(mat)
n_sector = nr + nc
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * (row_sum/(row_sum + col_sum)) +
small_gap*(nr-1)
gaps = c(rep(small_gap, nrow(mat) - 1), big_gap, rep(small_gap, ncol(mat) - 1), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
chordDiagram(mat, grid.col = grid.col)
circos.clear()
abline(v = 0, lty = 2, col = "#00000080")
gaps = c(rep(small_gap, nrow(mat) - 1), big_gap, rep(small_gap, ncol(mat) - 1), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
chordDiagram(mat)
circos.clear()
abline(v = 0, lty = 2, col = "#00000080")
gaps
nr
nc
mat
data
mat
str(data)
nrow(data)
nr
row_sum
col_sum
mat
as.matrix(data)
colSum(as.matrix(data))
colSums(as.matrix(data))
gather(mat, a, b, 2:6)
gather_(mat, a, b, 2:6)
gather(as.data.frame(mat), a, b, 2:6)
sum(gather(as.data.frame(mat), a, b, 2:6)[,3])
row_sum
mat
a
mat
sum(gather(as.data.frame(mat), a, b, 2:6)[,3])
mat1 <- as.data.frame(mat)
mat1
colnames(mat1)
sum(data)
data
row_sector_degree
small_gap = 1
big_gap = 20
nr = nrow(data)
nc = ncol(data)
n_sector = nr + nc
n_sector
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * 0.5 +
small_gap*(nr-1)
start_degree = 90 - (180 - row_sector_degree)/2
gaps = c(rep(small_gap, nrow(data) - 1), big_gap, rep(small_gap, ncol(data) - 1), big_gap)
gaps
circos.par(gap.after = gaps, start.degree = start_degree)
chordDiagram(a, annotationTrack = "grid")
circos.clear()
circos.par(gap.after = gaps, start.degree = start_degree)
chordDiagram(a, annotationTrack = "grid")
gaps
