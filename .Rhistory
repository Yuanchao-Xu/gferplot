gaps
load("~/GitHub/gferplot/data/CM.rda")
cm
set.seed(999)
mat = matrix(sample(18, 18), 3, 6)
rownames(mat) = paste0("S", 1:3)
colnames(mat) = paste0("E", 1:6)
row_sum = sum(rowSums(abs(mat)))
col_sum = sum(colSums(abs(mat)))
small_gap = 1
big_gap = 20
nr = nrow(mat)
nc = ncol(mat)
n_sector = nr + nc
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * (row_sum/(row_sum + col_sum)) +
small_gap*(nr-1)
start_degree = 90 - (180 - row_sector_degree)/2
gaps = c(rep(small_gap, nrow(mat) - 1), big_gap, rep(small_gap, ncol(mat) - 1), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
chordDiagram(mat, grid.col = grid.col)
circos.clear()
library(circlize)
circos.par(gap.after = gaps, start.degree = start_degree)
chordDiagram(mat, grid.col = grid.col)
circos.clear()
chordDiagram(mat)
circos.clear()
abline(v = 0, lty = 2, col = "#00000080")
circos.par(gap.after = gaps, start.degree = start_degree)
chordDiagram(mat)
circos.clear()
abline(v = 0, lty = 2, col = "#00000080")
gaps
row_sum/(row_sum + col_sum))
row_sum/(row_sum + col_sum)
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * 0.5) +
small_gap*(nr-1)
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * 0.5) + small_gap*(nr-1)
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * 0.5 + small_gap*(nr-1)
row_sector_degree
n_sector
data <- cm
a <- gather(data, 'responsibility', 'value', 2:ncol(data))
library(tidyr)
a <- gather(data, 'responsibility', 'value', 2:ncol(data))
str(data)
nrow(data)
n_sector
360 - small_gap*(n_sector - 2) - big_gap*2
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * 0.5 #+ small_gap*(nr-1)
start_degree = 90 - (180 - row_sector_degree)/2
gaps = c(rep(small_gap, nrow(data) - 1), big_gap, rep(small_gap, ncol(data) - 1), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
circos.clear()
abline(h = 0, lty = 2, col = "#00000080")
circos.par(gap.after = gaps, start.degree = start_degree)
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * 0.5 #+ small_gap*(nr-1)
start_degree = 90 - (180 - row_sector_degree)/2
gaps = c(rep(small_gap, nrow(mat) - 1), big_gap, rep(small_gap, ncol(mat) - 1), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
chordDiagram(mat)
circos.clear()
abline(v = 0, lty = 2, col = "#00000080")
start_degree = 85 - (180 - row_sector_degree)/2
gaps = c(rep(small_gap, nrow(mat) - 1), big_gap, rep(small_gap, ncol(mat) - 1), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
chordDiagram(mat)
abline(v = 0, lty = 2, col = "#00000080")
start_degree = 92 - (180 - row_sector_degree)/2
gaps = c(rep(small_gap, nrow(mat) - 1), big_gap, rep(small_gap, ncol(mat) - 1), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
chordDiagram(mat)
circos.clear()
abline(v = 0, lty = 2, col = "#00000080")
start_degree = 0 - (180 - row_sector_degree)/2
gaps = c(rep(small_gap, nrow(mat) - 1), big_gap, rep(small_gap, ncol(mat) - 1), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
chordDiagram(mat)
circos.clear()
abline(v = 0, lty = 2, col = "#00000080")
abline(h = 0, lty = 2, col = "#00000080")
nrow(mat)
nr = nrow(data)
nc = ncol(data)
n_sector = nr + nc
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * 0.5 #+ small_gap*(nr-1)
row_sector_degree
start_degree = 0 - (180 - row_sector_degree)/2
gaps = c(rep(small_gap, nrow(data) - 1), big_gap, rep(small_gap, ncol(data) - 1), big_gap)
gaps
circos.par(gap.after = gaps, start.degree = start_degree)
chordDiagram(a, annotationTrack = "grid")
chordDiagram(data, annotationTrack = "grid")
a <- as.matrix(data)
a
chordDiagram(a, annotationTrack = "grid")
as.numeric(data)
as.numeric(a)
a
circos.par(gap.after = gaps, start.degree = start_degree)
a <- as.matrix(data)
a <- as.matrix(data)
a <- gather(data, 'responsibility', 'value', 2:ncol(data))
chordDiagram(a, annotationTrack = "grid")
a <- as.matrix(data[2:ncol(data)])
a
chordDiagram(a, annotationTrack = "grid")
class(a)
str(a)
circos.clear()
a <- as.matrix(data[2:ncol(data)])
chordDiagram(a, annotationTrack = "grid")
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
str(a)
attr(a)
dimnames(a)
rownames(data)
data
dimnames(a)[[1]] <- data[,1]
chordDiagram(a, annotationTrack = "grid")
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
circos.clear()
circos.par(gap.after = gaps, start.degree = start_degree)
chordDiagram(a, annotationTrack = "grid")
a
str(a)
gaps
start_degree
circos.par()
gaps = c(rep(small_gap, nrow(a) - 1), big_gap, rep(small_gap, ncol(a) - 1), big_gap)
gaps
circos.par(gap.after = gaps, start.degree = start_degree)
chordDiagram(a, annotationTrack = "grid")
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * 0.5 + small_gap*(nr-1)
start_degree = 0 - (180 - row_sector_degree)/2
gaps = c(rep(small_gap, nrow(a) - 1), big_gap, rep(small_gap, ncol(a) - 1), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
circos.clear()
circos.par(gap.after = gaps, start.degree = start_degree)
chordDiagram(a, annotationTrack = "grid")
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
n_sector
nr
circos.clear()
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * 0.5 #+ small_gap*(nr-1)
start_degree = 0 - (180 - row_sector_degree)/2
gaps = c(rep(small_gap, nrow(a) - 1), big_gap, rep(small_gap, ncol(a) - 1), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
chordDiagram(a, annotationTrack = "grid")
start_degree
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * 0.5 + small_gap*(nr-1)
start_degree = 0 - (180 - row_sector_degree)/2
start_degree
a <- gather(data, 'responsibility', 'value', 2:ncol(data))
chordDiagram(a, annotationTrack = "grid")
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
a
ncol(data)
nc = ncol(data) - 1
n_sector = nr + nc
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * 0.5 + c
n_sector
nc = ncol(data) - 1
n_sector = nr + nc
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * 0.5 + small_gap*(nr-1)
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * 0.5 #+ small_gap*(nr-1)
start_degree = 0 - (180 - row_sector_degree)/2
gaps = c(rep(small_gap, nrow(a) - 1), big_gap, rep(small_gap, ncol(a) - 1), big_gap)
gaps = c(rep(small_gap, nrow(data) - 1), big_gap, rep(small_gap, ncol(data) - 2), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
circos.clear()
circos.par(gap.after = gaps, start.degree = start_degree)
chordDiagram(a, annotationTrack = "grid")
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
CELL_META$xcenter
CELL_META
CELL_META$sector.index
CELL_META$ylim[1]
data
m <- as.matrix(data[2:ncol(data)])
dimnames(a)[[1]] <- data[,1]
circos.clear()
if (ifsep == TRUE) {
# set up small gap and big gap, this is to seperate the whole circle into up and down part
small_gap = 1
big_gap = 20
# calculate how many sectors involved n_sector
nr = nrow(m)
nc = ncol(m)
n_sector = nr + nc
# calculate each sector takes up how many width, 0.5 means seperate into 2 parts, 0.25 means 4 parts
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * 0.5 #+ small_gap*(nr-1)
start_degree = 0 - (180 - row_sector_degree)/2
# calculate starting degree
gaps = c(rep(small_gap, nrow(data) - 1), big_gap, rep(small_gap, ncol(data) - 2), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
}
ifsep <- T
m <- as.matrix(data[2:ncol(data)])
dimnames(a)[[1]] <- data[,1]
circos.clear()
if (ifsep == TRUE) {
# set up small gap and big gap, this is to seperate the whole circle into up and down part
small_gap = 1
big_gap = 20
# calculate how many sectors involved n_sector
nr = nrow(m)
nc = ncol(m)
n_sector = nr + nc
# calculate each sector takes up how many width, 0.5 means seperate into 2 parts, 0.25 means 4 parts
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * 0.5 #+ small_gap*(nr-1)
start_degree = 0 - (180 - row_sector_degree)/2
# calculate starting degree
gaps = c(rep(small_gap, nrow(data) - 1), big_gap, rep(small_gap, ncol(data) - 2), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
}
chordDiagram(a, annotationTrack = "grid")
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
abline(h = 0, lty = 2, col = "#00000080")
CELL_META$xcenter
circos.text(CELL_META$xcenter + 1, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
chordDiagram(a, annotationTrack = "grid")
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter + 1, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
circos.text(CELL_META$xcenter - 1, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
chordDiagram(a, annotationTrack = "grid")
m <- as.matrix(data[2:ncol(data)])
dimnames(m)[[1]] <- data[,1]
circos.clear()
if (ifsep == TRUE) {
# set up small gap and big gap, this is to seperate the whole circle into up and down part
small_gap = 1
big_gap = 20
# calculate how many sectors involved n_sector
nr = nrow(m)
nc = ncol(m)
n_sector = nr + nc
# calculate each sector takes up how many width, 0.5 means seperate into 2 parts, 0.25 means 4 parts
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * 0.5 + small_gap*(nr-1)
start_degree = 0 - (180 - row_sector_degree)/2
# calculate starting degree
gaps = c(rep(small_gap, nrow(m) - 1), big_gap, rep(small_gap, ncol(m) - 1), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
}
chordDiagram(m, annotationTrack = "grid")
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter - 1, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1] + 1, CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
chordDiagram(m, annotationTrack = "grid")
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1] + 1, CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
chordDiagram(m, annotationTrack = "grid", transparency = 0)
trans = 0.7
chordDiagram(m, annotationTrack = "grid", transparency = trans)
chordDiagram(m, annotationTrack = "grid", transparency = 0.3)
chordDiagram(m, annotationTrack = "grid", transparency = 0.2)
chordDiagram(m, annotationTrack = c("name", "grid"), transparency = trans)
chordDiagram(m, annotationTrack = NULL, transparency = trans)
chordDiagram(m, annotationTrack = "grid", transparency = trans)
m
col_mat = rand_color(length(mat), transparency = 0.5)
col_mat
col_mat = rand_color(length(m), transparency = 0.5)
col_mat
grid.col = c(S1 = "red", S2 = "green", S3 = "blue",
E1 = "grey", E2 = "grey", E3 = "grey", E4 = "grey", E5 = "grey", E6 = "grey")
grid.col
cm
grid.col <- rep('grey', nrow(m) + ncol(m))
grid.col
grid.col = c(S1 = "red", S2 = "green", S3 = "blue",
E1 = "grey", E2 = "grey", E3 = "grey", E4 = "grey", E5 = "grey", E6 = "grey")
grid.col
rownames(grid.col)
dimnames(grid.col)
str(grid.col)
names(grid.col)
names(grid.col) <- c(dimnames(m)[[1]], dimnames(m)[[2]])
c(dimnames(m)[[1]], dimnames(m)[[2]])
grid.col <- rep('grey', nrow(m) + ncol(m))
names(grid.col) <- c(dimnames(m)[[1]], dimnames(m)[[2]])
chordDiagram(m, annotationTrack = "grid", transparency = trans, grid.col = NULL)
chordDiagram(m, annotationTrack = "grid", transparency = trans, grid.col = NULL)
grid.col <- rep('grey', nrow(m) + ncol(m))
names(grid.col) <- c(dimnames(m)[[1]], dimnames(m)[[2]])
chordDiagram(m, annotationTrack = "grid", transparency = trans, grid.col = grid.col)
highlight <- MEP
highlight <- 'MEP'
grid.col[highlight]
grid.col[highlight] <- 'red'
chordDiagram(m, annotationTrack = "grid", transparency = trans, grid.col = grid.col)
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1] + 2, CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
circos.clear()
chordDiagram(m, annotationTrack = "grid", transparency = trans, grid.col = grid.col)
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1] + 2, CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
grid.col <- NULL
chordDiagram(m, annotationTrack = "grid", transparency = trans, grid.col = grid.col)
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1] + 2, CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
m
m <- as.matrix(data[2:ncol(data)])
dimnames(m)[[1]] <- data[,1]
circos.clear()
if (ifsep == TRUE) {
# set up small gap and big gap, this is to seperate the whole circle into up and down part
small_gap = 1
big_gap = 20
# calculate how many sectors involved n_sector
nr = nrow(m)
nc = ncol(m)
n_sector = nr + nc
# calculate each sector takes up how many width, 0.5 means seperate into 2 parts, 0.25 means 4 parts
row_sector_degree = (360 - small_gap*(n_sector - 2) - big_gap*2) * 0.5 + small_gap*(nr-1)
start_degree = 0 - (180 - row_sector_degree)/2
# calculate starting degree
gaps = c(rep(small_gap, nrow(m) - 1), big_gap, rep(small_gap, ncol(m) - 1), big_gap)
circos.par(gap.after = gaps, start.degree = start_degree)
}
grid.col <- NULL
if (!is.null(highlight)) {
grid.col <- rep('grey', nrow(m) + ncol(m))
names(grid.col) <- c(dimnames(m)[[1]], dimnames(m)[[2]])
grid.col[highlight] <- 'red'
}
chordDiagram(m, annotationTrack = "grid", transparency = trans, grid.col = grid.col)
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1] + 2, CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
chordDiagram(m, annotationTrack = "grid", transparency = trans, grid.col = grid.col)
chordDiagram(m, annotationTrack = "grid", transparency = trans, grid.col = grid.col)
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1] + 2, CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
grid.col <- NULL
chordDiagram(m, annotationTrack = "grid", transparency = trans, grid.col = grid.col)
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1] + 2, CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
circos.par(gap.after = gaps, start.degree = start_degree, canvas.xlim = c(-1,-1))
circos.clear()
circos.par(gap.after = gaps, start.degree = start_degree, canvas.xlim = c(-1,-1))
chordDiagram(m, annotationTrack = "grid", transparency = trans, grid.col = grid.col)
circos.clear()
circos.par(gap.after = gaps, start.degree = start_degree, canvas.xlim = c(-1, -1), canvas.ylim = c(1, 1))
chordDiagram(m, annotationTrack = "grid", transparency = trans, grid.col = grid.col)
circos.par(gap.after = gaps, start.degree = start_degree, canvas.xlim = c(-2, 2), canvas.ylim = c(-2, 2))
circos.clear()
circos.par(gap.after = gaps, start.degree = start_degree, canvas.xlim = c(-2, 2), canvas.ylim = c(-2, 2))
chordDiagram(m, annotationTrack = "grid", transparency = trans, grid.col = grid.col)
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1] + 2, CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
xlim <- c(-3,3)
ylim <_ c(-3,3)
circos.clear()
circos.par(gap.after = gaps, start.degree = start_degree, canvas.xlim = xlim, canvas.ylim = ylim)
ylim
ylim <- c(-3,3)
circos.par(gap.after = gaps, start.degree = start_degree, canvas.xlim = xlim, canvas.ylim = ylim)
chordDiagram(m, annotationTrack = "grid", transparency = trans, grid.col = grid.col)
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1] + 2, CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
xlim <- NULL
ylim <- NULL
circos.clear()
circos.par(gap.after = gaps, start.degree = start_degree, canvas.xlim = xlim, canvas.ylim = ylim)
chordDiagram(m, annotationTrack = "grid", transparency = trans, grid.col = grid.col)
xlim = c(-1, 1)
ylim = c(-1, 1)
circos.clear()
circos.par(gap.after = gaps, start.degree = start_degree, canvas.xlim = xlim, canvas.ylim = ylim)
chordDiagram(m, annotationTrack = "grid", transparency = trans, grid.col = grid.col)
circos.track(track.index = 1, panel.fun = function(x, y) {
circos.text(CELL_META$xcenter, CELL_META$ylim[1] + 2, CELL_META$sector.index,
facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
}, bg.border = NA)
devtools::document()
devtools::check(cran = T)
plotChord(cm)
plotChord(cm, highlight = 'NDRC')
plotChord(cm, highlight = 'Investment')
m
t(m)
if (t == TRUE) m <- t(m)
devtools::check(cran = T)
devtools::check(cran = T)
devtools::check(cran = T)
plotChord(cm)
plotChord(cm, highlight = c('MEP', 'NDRC'))
plotChord(cm, t= T, highlight = 'Investment')
cm
t(cm)
mat
t(mat)
grid.col <- rep('grey', nrow(m) + ncol(m))
grid.col
names(grid.col) <- c(dimnames(m)[[1]], dimnames(m)[[2]])
grid.col[highlight] <- 'red'
plotChord(cm, highlight = 'Investment')
mat
mat1 <- mat
mat1 <- 'grey'
mat1
mat1 <- mat
mat1
mat1[] <- 'd'
mat1
grid.col <- a
grid.col[] <- 'grey'
grid.col
grid.col <- m
grid.col[] <- 'grey'
grid.col
chordDiagram(m, annotationTrack = "grid", transparency = trans, grid.col = grid.col)
length(grid.col)
col_mat[mat < 12]
col_mat
grid.col
grid.col[,'Investment']
grid.col['Investment']
grid.col['Investment',]
grid.col['MEP',]
grid.col[,'Investment'] <- 'red'
as.array(grid.col)
as.vestor(grid.col)
unlist(grid.col)
dim(grid.col)
dim(grid.col) <- c(1,1)
dim(grid.col) <- c(1,length(grid.col))
grid.col
chordDiagram(m, annotationTrack = "grid", transparency = trans, grid.col = grid.col)
col_mat
col <- grid.col
chordDiagram(m, annotationTrack = "grid", transparency = trans, col = col)
col
length(m)
unlist(col)
dim(col) <- c(1,length(col))
col
col_mat
grid.col <- m
grid.col[] <- 'grey'
c(col)
col <- c(col)
chordDiagram(m, annotationTrack = "grid", transparency = trans, col = col)
names(m)
dimnames(m)
highlight in dimneams(m[[1]])
highlight %in% dimneams(m[[1]])
highlight %in% dimnames(m[[1]])
highlight
highlight %in% dimnames(m[[2]])
highlight %in% dimnames(m[[1]])
plotChord(cm)
dimnames(m[[1]])
highlight %in% dimnames(m)[[1]]
highlight %in% dimnames(m)[[2]]
devtools::check(cran = T)
plotChord(cm)
plotChord(t(cm))
plotChord(cm, t = T)
plotChord(cm, highlight = 'MEP')
plotChord(cm, highlight = 'Investment')
plotChord(cm, highlight = 'MEP')
rm(ls())
ls()
rm(list = ls())
